# 🔐 Chaos-Aided Quantization Index Modulation (Chaos-QIM)
> Official implementation of the paper:  
> **Secure Steganography Based on Chaos-Aided Quantization Index Modulation** by Xinquan Xu, Ling Liu, Shanxiang Lyu, Lip Yee Por


## 📘 Overview
**Chaos-QIM** is a secure steganographic framework that integrates the strengths of **Quantization Index Modulation (QIM)** and **chaotic systems** to achieve both imperceptibility and robustness in covert communication.


Traditional QIM techniques often alter the statistical properties of the host signal, making them vulnerable to detection through statistical steganalysis, while chaotic steganography introduces significant distortion or complexity. Chaos-QIM overcomes these limitations by embedding messages using **uniformly distributed dither** generated by **chaotic sequence** within a **lattice-based QIM** framework.
- ✅ Statistical indistinguishability of the stego-signal  
- ✅ Resistance against statistical steganalysis (e.g., histogram, chi-squared attacks)  
- ✅ High embedding capacity with low distortion  
- ✅ Enhanced security by introducing chaos-generated external dithers in the emdedding process

> Chaos-QIM achieves a balance between security, capacity, and signal quality, making it well-suited for real-world covert communication scenarios under adversarial analysis.


---

## 📂 Repository Structure
```
chaos-qim/
├── Lattice/ # Lattice-related modules
│ ├── Lattice_basis.py
│ ├── Lattice_covering.py
│ ├── Lattice_mean_square.py
│ ├── Lattice_operation.py
│ ├── Lattice_packing.py
│ └── lattice_information.py
├── Chaos-QIM.py # Main implementation of Chaos-QIM embedding & extraction
├── Logistic.py # Transform sequence to uniform distribution
├── QIM.py # Baseline lattice-based QIM
├── SDCVP.py # Lattice Encode and Decode
├── proposed_Lorenz.py # Enhanced Lorenz chaotic system with delay
├── README.md
```
---

## ⚙️ Dependencies
Install dependencies with:
```bash
pip install numpy math
```

## 🚀 Quick Start
- ▶️Embedding messages
```python
def chaos_qim_embedding(p: np.array, s: np.array, basic: np.array, a: int,
                        representative: list[np.array], dither: np.array) -> np.array:
    """
     p: carrier signal
     s: secret message
     b: lattice basis
     a: magnification factor
     representative: coset representative
     dither: external dither

    """

    sub_basic = a * basic
    k = np.dot(sub_basic,
               SDCVP(p - dither - np.dot(basic, representative[s]), sub_basic))
    m = k + np.dot(basic, representative[s]) + dither
    return m

num = 0
for item in range(0, len(carrier), N):
        carrier_sample = chaos_qim_embedding(carrier[item: item + N], secret[num], m, alpha, coset_representative,edf_dither3[item:item + N])
        chaos_sequence = np.concatenate([chaos_sequence, carrier_sample])
        num += 1
```

- ▶️extract messages
```python
def chaos_qim_extraction(p: np.array, basic: np.array, a: int, representative: list[np.array],
                         dither: np.array) -> int:
    k = SDCVP(p - dither, basic, )
    for i in range(len(representative)):
        if (k % a == representative[i]).all():
            break
    return i

for item in range(0, round(len(chaos_sequence)), N):
    coset_index = chaos_qim_extraction(chaos_sequence[item:item + N], m, alpha, coset_representative, edf_dither3[item:item + N])
    secret_extration.append(coset_index)
```
> You may configure different lattice bases (A<sub>2</sub>, A<sub>3</sub>, D<sub>4</sub>, <sub>5</sub>), chaotic maps (Logistic, Lorenz), and payload lengths in the script.
> This script is applicable not only to synthetic sequences but can also be extended to real-world media such as images, audio, and other digital signals.



